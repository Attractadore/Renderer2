#include "MeshletCullingPass.h"
#include "Vertex.h"

PUSH_CONSTANTS(MeshletCullingPassArgs);

NUM_THREADS(MESHLET_CULLING_THREADS);
void main() {
  const uint bucket_size = DEREF(pc.bucket_size);
  const uint bucket_stride = 1 << pc.bucket;
  const bool cone_culling = bool(pc.feature_mask & MESHLET_CULLING_CONE_BIT);
  const bool frustum_culling = bool(pc.feature_mask & MESHLET_CULLING_FRUSTUM_BIT);

  const uint index = gl_GlobalInvocationID.x / bucket_stride;
  const uint offset = gl_GlobalInvocationID.x % bucket_stride;

  if (index >= bucket_size) {
    return;
  };

  MeshletCullData cull_data = DEREF(pc.bucket_cull_data[index]);
  Mesh mesh = DEREF(pc.meshes[cull_data.mesh]);
  Meshlet meshlet = DEREF(mesh.meshlets[cull_data.base_meshlet + offset]);

  mat4x3 transform_matrix = DEREF(pc.transform_matrices[cull_data.mesh_instance]);

  if (cone_culling) {
    vec3 cone_apex = transform_matrix * vec4(decode_position(meshlet.cone_apex), 1.0f);
    vec3 cone_axis = transform_matrix * vec4(decode_position(meshlet.cone_axis), 0.0f);
    if (dot(cone_apex - pc.eye, normalize(cone_axis)) >= meshlet.cone_cutoff * length(cone_apex - pc.eye)) {
      return;
    }
  }

  if (frustum_culling) {
    mat4 pvm = pc.proj_view * mat4(transform_matrix);
  
    BoundingBox bb = decode_bounding_box(meshlet.bb);
  
    vec3 bbs = bb.max - bb.min;
  
    vec4 px = pvm * vec4(bbs.x, 0.0f, 0.0f, 0.0f);
    vec4 py = pvm * vec4(0.0f, bbs.y, 0.0f, 0.0f);
    vec4 pz = pvm * vec4(0.0f, 0.0f, bbs.z, 0.0f);
  
    vec4 p[8];
    p[0] = pvm * vec4(bb.min, 1.0f);
    p[1] = p[0] + px;
    p[2] = p[1] + py;
    p[3] = p[0] + py;
    p[4] = p[0] + pz;
    p[5] = p[1] + pz;
    p[6] = p[2] + pz;
    p[7] = p[3] + pz;
  
    float n = p[0].z;
  
    float zmin = p[0].w;
    float zmax = p[0].w;
    for (int i = 1; i < 8; ++i) {
      zmin = min(zmin, p[i].w);
      zmax = max(zmax, p[i].w);
    }
  
    // Cull if bounding box is in front of near plane
    if (zmax < n) {
      return;
    }
  
    if (zmin > n) {
      vec2 s[8];
      for (int i = 0; i < 8; ++i) {
        s[i] = p[i].xy / p[i].w;
      }
      vec2 smin = s[0];
      vec2 smax = s[0];
      for (int i = 1; i < 8; ++i) {
        smin = min(smin, s[i]);
        smax = max(smax, s[i]);
      }
      // Ignore far plane
      if (any(lessThan(smax, vec2(-1.0f))) || any(greaterThan(smin, vec2(1.0f)))) {
        return;
      }
    }
  }

  DrawIndexedIndirectCommand command;
  command.num_indices = meshlet.num_triangles * 3;
  command.num_instances = 1;
  command.base_index = meshlet.base_triangle;
  command.base_vertex = meshlet.base_index;
  command.base_instance = cull_data.mesh_instance;

  uint command_offset;
  uint num_commands = subgroupAdd(1);
  if (subgroupElect()) {
    command_offset = atomicAdd(DEREF(pc.num_commands), num_commands);
  }
  command_offset = subgroupBroadcastFirst(command_offset) + subgroupExclusiveAdd(1);

  DEREF(pc.commands[command_offset]) = command;
}
