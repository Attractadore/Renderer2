#include "InstanceCullingAndLODPass.h"
#include "Math.h"

PUSH_CONSTANTS(InstanceCullingAndLODPassArgs);

NUM_THREADS(INSTANCE_CULLING_AND_LOD_THREADS);
void main() {
  const uint STRIDE = gl_NumWorkGroups.x * gl_WorkGroupSize.x;
  const bool frustum_culling = bool(pc.feature_mask & INSTANCE_CULLING_AND_LOD_FRUSTUM_BIT);
  const bool lod_selection = bool(pc.feature_mask & INSTANCE_CULLING_AND_LOD_LOD_SELECTION_BIT);

  for (uint i = gl_GlobalInvocationID.x; i < pc.num_mesh_instances; i += STRIDE) {
    MeshInstance mesh_instance = pc.mesh_instances[i].mesh_instance;
    Mesh mesh = pc.meshes[mesh_instance.mesh].mesh;

    mat4 pvm = pc.proj_view * mat4(pc.transform_matrices[i].matrix);

    BoundingBox bb = decode_bounding_box(mesh.bb);

    vec3 bbs = bb.max - bb.min;

    vec4 px = pvm * vec4(bbs.x, 0.0f, 0.0f, 0.0f);
    vec4 py = pvm * vec4(0.0f, bbs.y, 0.0f, 0.0f);
    vec4 pz = pvm * vec4(0.0f, 0.0f, bbs.z, 0.0f);

    vec4 p[8];
    p[0] = pvm * vec4(bb.min, 1.0f);
    p[1] = p[0] + px;
    p[2] = p[1] + py;
    p[3] = p[0] + py;
    p[4] = p[0] + pz;
    p[5] = p[1] + pz;
    p[6] = p[2] + pz;
    p[7] = p[3] + pz;

    float n = p[0].z;

    float zmin = p[0].w;
    float zmax = p[0].w;
    for (int i = 1; i < 8; ++i) {
      zmin = min(zmin, p[i].w);
      zmax = max(zmax, p[i].w);
    }

    // Cull if bounding box is in front of near plane
    if (frustum_culling && zmax < n) {
      continue;
    }

    int l = 0;
    // Select highest lod and don't cull if bounding box crosses near plane
    if (zmin > n) {
      vec2 s[8];
      for (int i = 0; i < 8; ++i) {
        s[i] = p[i].xy / p[i].w;
      }
      vec2 smin = s[0];
      vec2 smax = s[0];
      for (int i = 1; i < 8; ++i) {
        smin = min(smin, s[i]);
        smax = max(smax, s[i]);
      }
      // Ignore far plane
      if (frustum_culling && (any(lessThan(smax, vec2(-1.0f))) || any(greaterThan(smin, vec2(1.0f))))) {
        continue;
      }
      if (lod_selection) {
        uvec4 faces[6] = {
          // Top
          uvec4(7, 5, 6, 4),
          // Bottom
          uvec4(3, 1, 2, 0),
          // Right
          uvec4(5, 2, 6, 1),
          // Left
          uvec4(4, 3, 7, 0),
          // Front
          uvec4(4, 1, 5, 0),
          // Back
          uvec4(7, 2, 6, 3),
        };
        // Compute total front and back-facing projected area
        float area = 0.0f;
        for (int f = 0; f < 6; ++f) {
          uvec4 face = faces[f];
          area += abs(determinant(mat2(s[face.x] - s[face.y], s[face.z] - s[face.w])));
        }
        // Face area is half of abs of det of matrix of diagonals
        area /= 2.0f;
        uint num_triangles = uint(area * pc.lod_triangle_density);
        uint num_indices = num_triangles * 3;
        for (; l < mesh.num_lods - 1; ++l) {
          if (mesh.lods[l].num_indices <= num_indices) {
            break;
          }
        }
      }
    }

    l = clamp(l - pc.lod_bias, 0, int(mesh.num_lods - 1));
    MeshLOD lod = mesh.lods[l];

    uint base_meshlet = lod.base_meshlet;
    uint num_meshlets = lod.num_meshlets;
    while (num_meshlets) {
      uint bucket = findLSB(num_meshlets);
      uint bucket_size = 1 << bucket;

      MeshletCullingData data;
      data.mesh = mesh_instance.mesh;
      data.mesh_instance = i;
      data.base_meshlet = base_meshlet;

      base_meshlet += bucket_size;
      num_meshlets &= ~bucket_size;

      uint bucket_base_offset = pc.meshlet_bucket_offsets[bucket];
      uint bucket_offset = atomicAdd(pc.meshlet_bucket_counts[bucket], 1);
      uint bucket_count = bucket_offset + 1;
      pc.meshlet_culling_data[bucket_base_offset + bucket_offset] = data;

      uint old_num_bucket_threads = (bucket_count - 1) * bucket_size;
      uint old_num_bucket_work_groups = ceil_dev(old_num_bucket_threads, MESHLET_CULLING_THREADS);
      uint num_bucket_threads = bucket_count * bucket_size;
      uint num_bucket_work_groups = ceil_dev(num_bucket_threads, MESHLET_CULLING_THREADS);
      if (old_num_bucket_work_groups != num_bucket_work_groups) {
        atomicMax(pc.meshlet_bucket_commands[bucket].command.x, num_bucket_work_groups);
      }
    }
  }
}
